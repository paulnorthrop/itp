---
title: "Overview of the itp package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Overview of the itp package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: itp.bib
csl: taylor-and-francis-chicago-author-date.csl
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5, 
  fig.height = 3,
  global.par = TRUE
)
```

The Interpolate, Truncate, Project (ITP) root-finding algorithm was developed in @OliveiraTakahashi2021. It's performance compares favourably with existing methods on both well-behaved functions and ill-behaved functions while retaining the worst-case reliability of the bisection method. For details see the authors' [Kudos summary](https://www.growkudos.com/publications/10.1145%25252F3423597/reader) and the Wikipedia article [ITP method](https://en.wikipedia.org/wiki/ITP_method).

The `itp` function implements the ITP method to find a root $x^*$ of the function $f: \mathbb{R} \rightarrow \mathbb{R}$ in the interval $[a, b]$, where $f(a)f(b) < 0$. If $f$ is continuous over $[a, b]$ then $f(x^*) = 0$. If $f$ is discontinuous over $[a, b]$ then $x^*$ may be an estimate of a point of discontinuity at which the sign of $f$ changes, that is, $f(x^* - \delta)f(x^* + \delta) \leq 0$, where $0 \leq \delta \leq \epsilon$ for some tolerance value $\epsilon$.

We use some of the examples presented in Table 1 of @OliveiraTakahashi2021 to illustrate the use of this function and run the examples using the `uniroot` function in the `stats` package as a means of comparison, using a convergence tolerance of $10^{-10}$ in both cases. The `itp` function uses the following default values of the tuning parameters: $\kappa_1 = 0.2 / (b - a)$, $\kappa_2 = 2$ and $n_0 = 1$, but these may be changed by the user.  See Sections 2 and 3 of  @OliveiraTakahashi2021 for information. The following function prints output from `uniroot` in the same style as the output from `itp`.

```{r}
# Method to print part of uniroot output
print.list <- function(x, digits = max(3L, getOption("digits") - 3L)) {
  names(x)[1:3] <- c("root", "f(root)", "iterations")
  print.default(format(x[1:3], digits = digits), print.gap = 2L, quote = FALSE)
}
```

```{r setup}
library(itp)
```

## Well-behaved functions

These functions are infinitely differentiable and contain only one simple root over $[âˆ’1, 1]$.

### Lambert: $f(x) = x e^x - 1$

```{r}
# Lambert
lambert <- function(x) x * exp(x) - 1
itp(lambert, c(-1, 1))
uniroot(lambert, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(lambert, -1, 1, main = "Lambert")
abline(h = 0, lty = 2)
abline(v = itp(lambert, c(-1, 1))$root, lty = 2)
par(oldpar)
```

### Trigonometric 1: $f(x) = \tan(x - 1 / 10)$

```{r}
# Trigonometric 1
trig1 <- function(x) tan(x - 1 /10)
itp(trig1, c(-1, 1))
uniroot(trig1, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(trig1, -1, 1, main = "Trigonometric 1")
abline(h = 0, lty = 2)
abline(v = itp(trig1, c(-1, 1))$root, lty = 2)
par(oldpar)
```

## Ill-behaved functions

### Polynomial 3: $f(x) = (10^6 x - 1) ^ 3$

This function has a non-simple root at $10^{-6}$, with a multiplicity of 3.

```{r}
# Polynomial 3
poly3 <- function(x) (x * 1e6 - 1) ^ 3
itp(poly3, c(-1, 1))
# Using n0 = 0 leads to (slightly) fewer iterations, in this example
poly3 <- function(x) (x * 1e6 - 1) ^ 3
itp(poly3, c(-1, 1), n0 = 0)
uniroot(poly3, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(poly3, -1, 1, main = "Polynomial 3")
abline(h = 0, lty = 2)
abline(v = itp(poly3, c(-1, 1))$root, lty = 2)
par(oldpar)
```

### Discontinuous

### Staircase: $f(x) = \lceil 10 x - 1 \rceil + 1/2$

This function has discontinuities, including one at the location of the root.

```{r}
# Staircase
staircase <- function(x) ceiling(10 * x - 1) + 1 / 2
itp(staircase, c(-1, 1))
uniroot(staircase, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(staircase, -1, 1, main = "Staircase", n = 10000)
abline(h = 0, lty = 2)
abline(v = itp(staircase, c(-1, 1))$root, lty = 2)
par(oldpar)
```

### Multiple roots

### Warsaw: $f(x) = I(x > -1)\left(1 + \sin\left(\frac{1}{1+x}\right)\right)-1$

This function has multiple roots: we find two of them.

```{r}
# Warsaw
warsaw <- function(x) ifelse(x > -1, sin(1 / (x + 1)), -1)
# Function increasing over the interval
itp(warsaw, c(-1, 1))
uniroot(warsaw, c(-1, 1), tol = 1e-10)
# Function decreasing over the interval
itp(warsaw, c(-0.85, -0.8))
uniroot(warsaw, c(-0.85, -0.8), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(warsaw, -0.9999999, 1, main = "Warsaw", n = 1000)
abline(h = 0, lty = 2)
abline(v = itp(warsaw, c(-1, 1))$root, lty = 2)
abline(v = itp(warsaw, c(-0.85, -0.8))$root, lty = 2)
par(oldpar)
```

In terms of a naive comparison based on the number of iterations `itp` and `uniroot` perform similarly, except in the repeated-root "Polynomial 3" example, where `itp` requires fewer iterations.  

## References

<script type="text/x-mathjax-config">
   MathJax.Hub.Config({  "HTML-CSS": { minScaleAdjust: 125, availableFonts: [] }  });
</script>
